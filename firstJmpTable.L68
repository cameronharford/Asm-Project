00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 7/16/2020 11:51:04 PM

00000000                             1      INCLUDE     "dependencies.X68"
00000000                             2      INCLUDE     "print.X68"
00000000                             3          OPT     MEX
00000000  =00000000                  4  CODE    EQU     0
00000000  =00000001                  5  TEXT    EQU     1
00000000                             6  
00000000                             7      SECTION     TEXT
00002000                             8      ORG         $2000
00000000                             9      SECTION     CODE
00001000                            10      ORG         $1000
00001000                            11  
00001000                            12  PRINT   MACRO
00001000                            13      SECTION     TEXT
00001000                            14  MSG\@    DC.B    '\1'
00001000                            15      IFARG    2
00001000                            16          IFC      '\2','ENDL'
00001000                            17              DC.B    $D,$A
00001000                            18          ENDC
00001000                            19      ENDC
00001000                            20      DC.B    0
00001000                            21      SECTION     CODE
00001000                            22      MOVEM.L     D0/A1,-(SP)
00001000                            23      LEA         MSG\@,A1
00001000                            24      MOVE.B      #14,D0
00001000                            25      TRAP        #15
00001000                            26      MOVEM.L     (SP)+,D0/A1
00001000                            27      ENDM
00001000                            28  
00001000                            29  PRINTN    MACRO
00001000                            30      SECTION     CODE
00001000                            31      MOVEM.L     D0/D1,-(SP)
00001000                            32      IFNC '\1','D1'          if some register other than D1
00001000                            33          MOVE.L    \1,D1       put number to display in D1
00001000                            34      ENDC
00001000                            35      IFEQ NARG-2         ; for unsigned ints
00001000                            36          MOVE.B  #15,D0
00001000                            37          MOVE.B  \2,D2   ; arg 2 is the new num base (ex: #16)
00001000                            38      ENDC
00001000                            39      IFEQ NARG-1         ; for signed ints
00001000                            40          MOVE.B  #3,D0
00001000                            41      ENDC
00001000                            42      TRAP    #15             display number in D1
00001000                            43      MOVEM.L (SP)+,D0/D1
00001000                            44      ENDM
00001000                            45  
00001000                            46  
00001000                            47  
00001000                            48  
00001000                            49  
00001000                            50  
00001000                            51  
00001000                            52  
00001000                            53  
00001000                            54  
00001000                            55  -------------------- end include --------------------
00001000                            56      INCLUDE     "isolateBits.X68"
00001000                            57  isolateBits
00001000                            58      ; D0 contains the number you'd like to isolate bits on
00001000                            59      ; D1 contains the starting bit number, ranging from 31-0
00001000                            60      ; D2 contains the stopping bit number, ranging from 30-0
00001000                            61      
00001000                            62      ; Save D3 before we overwrite it
00001000  2F03                      63      MOVE.L      D3,-(SP)
00001002                            64      
00001002                            65      ; D3 = 31 - D1 
00001002  761F                      66      MOVE.L      #31, D3
00001004  9601                      67      SUB.B       D1, D3 
00001006                            68  
00001006                            69      ; D0 = D0 << D3
00001006  E7A8                      70      LSL.L       D3, D0
00001008                            71  
00001008                            72      ; D3 = D3 + D2 
00001008  D602                      73      ADD.B       D2, D3
0000100A                            74  
0000100A                            75      ; D0 = D0 >> D3
0000100A  E6A8                      76      LSR.L       D3, D0
0000100C                            77      
0000100C                            78      ; Restore D3 then return
0000100C  261F                      79      MOVE.L      (SP)+,D3
0000100E  4E75                      80      RTS
00001010                            81  
00001010                            82  ; example call:
00001010                            83  ;   MOVE.L      #$1234, D0
00001010                            84  ;   MOVE.B      #11, D1
00001010                            85  ;   MOVE.B      #8, D2
00001010                            86  ;   BSR         isolateBits
00001010                            87  ;
00001010                            88  ; return from this call:
00001010                            89  ;   D0 = 0x2
00001010                            90  
00001010                            91      
00001010                            92  isolateBitsM    MACRO
00001010                            93      ; args same as above, except they're immediates or different regs
00001010                            94      IFNE NARG-3                       ;if not 3 arguments
00001010                            95          FAIL ERROR, isolateBits requires 3 arguments
00001010                            96          MEXIT
00001010                            97      ENDC
00001010                            98      MOVE.L      \1,D0
00001010                            99      MOVE.B      \2,D1
00001010                           100      MOVE.B      \3,D2
00001010                           101      BSR         isolateBits
00001010                           102      ENDM
00001010                           103      
00001010                           104  ; example call:
00001010                           105  ;   isolateBitsM    #$1234,#11,#8
00001010                           106  ;
00001010                           107  ; same as the above example
00001010                           108  ; returns D0 = 0x2
00001010                           109  -------------------- end include --------------------
00001010                           110      INCLUDE     "calcJmpOffset.X68"
00001010                           111  ; this is a helper method I made to simplify the jump table address calculation
00001010                           112  calcJmpOffset
00001010                           113      ; this method assumes A0 points to a jump table and D0 contains some number of bits of an instruction   
00001010                           114      ; each jmp table entry is 6 bytes (2 for word opcode, 4 for jump address)
00001010  C0FC 0006                115      MULU        #6, D0      *Form offset     
00001014  4EB0 0000                116      JSR         0(A0, D0)   *Jump indirect with index
00001018                           117      
00001018  4E75                     118      RTS ; JSR loads the address of this RTS instruction into the SR so it eventually branches back
00001018  4E75                     119  -------------------- end include --------------------
0000101A                           120      INCLUDE     "calcDisplacement.X68"
0000101A                           121  ; calculates displacement from branch instruction opcodes (hex)
0000101A                           122  calcDisplacementAddress
0000101A                           123      ; D4 holds 16-bit opcode
0000101A  1004                     124      MOVE.B  D4,D0
0000101C  4400                     125      NEG.B   D0
0000101E  0280 000000FF            126      ANDI.L  #$FF,D0             ; clear just in case
00001024                           127      ; If D0 is 0 here, that means the branch goes to a lower addr
00001024                           128      ; This means the instruction uses an extension with the actual displacement
00001024                           129      
00001024                           130      ;SUB.W   D0,PROGRAM_COUNTER  ; this could be an EQU for an addr reg
00001024  4E75                     131      RTS    
00001026                           132  
00001026                           133  -------------------- end include --------------------
00001026                           134  
00001026                           135  
00001026                           136  
00001026                           137  
00001026                           138  
00001026                           139  getOpcode
00001026                           140      ; clear D0 just in case it has high order bits
00001026  0280 00000000            141      ANDI.L  #$0,D0
0000102C                           142      
0000102C                           143      ; load the word and return
0000102C  43F9 00001082            144      LEA     INSTR_OPCODE_WORD,A1
00001032  3011                     145      MOVE.W  (A1),D0
00001034  4E75                     146      RTS
00001036                           147      
00001036                           148  getFirstExt
00001036  43F9 00001084            149      LEA     INSTR_EXT_1,A1
0000103C  6000 0008                150      BRA     getExtension
00001040                           151      
00001040                           152  getSecondExt
00001040  43F9 00001088            153      LEA     INSTR_EXT_2,A1
00001046                           154      ; don't even need to branch lol
00001046                           155  
00001046                           156  getExtension
00001046                           157      ; in any case we'll load D0 and return
00001046  2011                     158      MOVE.L  (A1),D0
00001048                           159      
00001048                           160      ; check for null value so we don't waste instructions
00001048                           161      ; this should work as a zero compare
00001048  6700 0018                162      BEQ     getExtensionReturn
0000104C                           163      
0000104C                           164      ; check if the extension is a word
0000104C  0C69 0000 0004           165      CMP.W   #0,4(A1)
00001052  6600 000E                166      BNE     getExtensionReturn
00001056                           167      
00001056                           168      ; it is, so we need to account for byte order
00001056                           169      ; it'd be faster to do this by hand but I'm lazy
00001056                           170m     isolateBitsM    D0,#31,#16    
00001056                           171m     ; ARGS SAME AS ABOVE, EXCEPT THEY're immediates or different regs
00001056                 FALSE     172m     IFNE 3-3                       ;IF NOT 3 ARGUMENTS
00001056                           173m     ENDC
00001056  2000                     174m     MOVE.L      D0,D0
00001058  123C 001F                175m     MOVE.B      #31,D1
0000105C  143C 0010                176m     MOVE.B      #16,D2
00001060  619E                     177m     BSR         ISOLATEBITS
00001062                           178m     ENDM
00001062                           179      ; same as D0 = D0 >> 16
00001062                           180      
00001062                           181  getExtensionReturn
00001062  4E75                     182      RTS
00001064                           183      
00001064                           184  setOpcode
00001064                           185      ; ensure there's nothing lurking in D0's upper word
00001064  0280 0000FFFF            186      ANDI.L  #$FFFF,D0
0000106A                           187      ; set the variable
0000106A  33C0 00001082            188      MOVE.W  D0,(INSTR_OPCODE_WORD)
00001070  4E75                     189      RTS
00001072                           190      
00001072                           191  setFirstExt
00001072  23C0 00001084            192      MOVE.L  D0,(INSTR_EXT_1)
00001078  4E75                     193      RTS
0000107A                           194      
0000107A                           195  setSecondExt
0000107A  23C0 00001088            196      MOVE.L  D0,(INSTR_EXT_2)
00001080  4E75                     197      RTS
00001082                           198      
00001082                           199  ; TODO: Macro for these setters
00001082                           200  
00001082                           201  INSTR_BYTES         DS.B    10  
0000108C                           202  
0000108C                           203  
0000108C  =00001082                204  INSTR_OPCODE_WORD   EQU     INSTR_BYTES     
0000108C                           205  
0000108C  =00001084                206  INSTR_EXT_1         EQU     (INSTR_BYTES)+2 
0000108C                           207  
0000108C  =00001088                208  INSTR_EXT_2         EQU     (INSTR_BYTES)+6 
0000108C                           209  
0000108C                           210  
0000108C                           211  
0000108C                           212  
0000108C                           213  invalidOpcode   
0000108C                           214m     PRINT       <Error: Invalid opcode! >
00002000                           215m     SECTION     TEXT
00002000= 45 52 52 4F 52 3A 20     216  MSG_2    DC.B    'ERROR: INVALID OPCODE! '
          49 4E 56 41 4C 49 44  
          20 4F 50 43 4F 44 45  
          21 20                 
00002017                 FALSE     220m     IFARG    2
00002017                           221m     ENDC
00002017= 00                       222m     DC.B    0
0000108C                           223m     SECTION     CODE
0000108C  48E7 8040                224m     MOVEM.L     D0/A1,-(SP)
00001090  43F8 2000                225m     LEA         MSG_2,A1
00001094  103C 000E                226m     MOVE.B      #14,D0
00001098  4E4F                     227m     TRAP        #15
0000109A  4CDF 0201                228m     MOVEM.L     (SP)+,D0/A1
0000109E                           229m     ENDM
0000109E                           230m     PRINT       <(this instruction is not supported)>,ENDL
00002018                           231m     SECTION     TEXT
00002018= 28 54 48 49 53 20 49     232  MSG_3    DC.B    '(THIS INSTRUCTION IS NOT SUPPORTED)'
          4E 53 54 52 55 43 54  
          49 4F 4E 20 49 53 20  
          4E 4F 54 20 53 55 50  
          50 4F 52 54 45 44 29  
0000203B                 TRUE      237m     IFARG    2
0000203B                 TRUE      238m         IFC      'ENDL','ENDL'
0000203B= 0D 0A                    239m             DC.B    $D,$A
0000203D                           240m         ENDC
0000203D                           241m     ENDC
0000203D= 00                       242m     DC.B    0
0000109E                           243m     SECTION     CODE
0000109E  48E7 8040                244m     MOVEM.L     D0/A1,-(SP)
000010A2  43F8 2018                245m     LEA         MSG_3,A1
000010A6  103C 000E                246m     MOVE.B      #14,D0
000010AA  4E4F                     247m     TRAP        #15
000010AC  4CDF 0201                248m     MOVEM.L     (SP)+,D0/A1
000010B0                           249m     ENDM
000010B0  4E75                     250      RTS
000010B2                           251      
000010B2                           252  
000010B2                           253  
000010B2                           254  
000010B2                           255  
000010B2                           256  
000010B2                           257  
000010B2                           258  -------------------- end include --------------------
000010B2                           259      INCLUDE     "secondJmpTable.X68"
000010B2                           260  ; second level of jump tables
000010B2                           261  ; uses bits 11-9 to narrow search down further
000010B2                           262  ; note: not all instructions use one of these jump tables. Some like moveQ only require the first table, while others don't have consistent 11-9 bit values to allow a jump table to differentiate
000010B2                           263  
000010B2                           264  ; STOP #$DEAD means we don't need to interpret this instruction for the project
000010B2                           265  ; TODO: simplify unrequired jump tables
000010B2                           266      
000010B2                           267  ; 0100
000010B2                           268  jmpTable0100
000010B2  4E72 0100                269      STOP        #$0100 *JMP         sub_MOVE_from_SR * not required
000010B6  4E72 0100                270      STOP        #$0100 *JMP         sub_MOVE_to_CCR * not required
000010BA  4E72 0100                271      STOP        #$0100 *JMP         sub_MOVE_to_SR * not required
000010BE  4E72 DEAD                272      STOP        #$DEAD *JMP         sub_NEGX * not required
000010C2  4E72 DEAD                273      STOP        #$DEAD *JMP         sub_CLR * not required
000010C6  4E72 DEAD                274      STOP        #$DEAD *JMP         sub_NEG * not required
000010CA                           275      
000010CA  4E72 0100                276      STOP        #$0100 *JMP         sub_NOT
000010CE                           277      
000010CE  4E72 DEAD                278      STOP        #$DEAD *JMP         sub_EXT * not required
000010D2  4E72 DEAD                279      STOP        #$DEAD *JMP         sub_NBCD * not required
000010D6  4E72 DEAD                280      STOP        #$DEAD *JMP         sub_SWAP * not required
000010DA  4E72 DEAD                281      STOP        #$DEAD *JMP         sub_PEA * not required
000010DE  4E72 DEAD                282      STOP        #$DEAD *JMP         sub_ILLEGAL * not required
000010E2  4E72 DEAD                283      STOP        #$DEAD *JMP         sub_TAS * not required
000010E6  4E72 DEAD                284      STOP        #$DEAD *JMP         sub_TST * not required
000010EA  4E72 DEAD                285      STOP        #$DEAD *JMP         sub_TRAP * not required
000010EE  4E72 DEAD                286      STOP        #$DEAD *JMP         sub_LINK * not required
000010F2  4E72 DEAD                287      STOP        #$DEAD *JMP         sub_UNLK * not required
000010F6  4E72 DEAD                288      STOP        #$DEAD *JMP         sub_MOVE_USP * not required
000010FA  4E72 DEAD                289      STOP        #$DEAD *JMP         sub_RESET * not required
000010FE                           290      
000010FE  4E72 0100                291      STOP        #$0100 *JMP         sub_NOP
00001102                           292      
00001102  4E72 DEAD                293      STOP        #$DEAD *JMP         sub_STOP * not required
00001106  4E72 DEAD                294      STOP        #$DEAD *JMP         sub_RTE * not required
0000110A                           295      
0000110A  4E72 0100                296      STOP        #$0100 *JMP         sub_RTS
0000110E                           297      
0000110E  4E72 DEAD                298      STOP        #$DEAD *JMP         sub_TRAPV * not required
00001112  4E72 DEAD                299      STOP        #$DEAD *JMP         sub_RTR * not required
00001116                           300      
00001116  4E72 0100                301      STOP        #$0100 *JMP         sub_JSR
0000111A                           302      
0000111A  4E72 DEAD                303      STOP        #$DEAD *JMP         sub_JMP * not required
0000111E                           304      
0000111E  4E72 0100                305      STOP        #$0100 *JMP         sub_MOVEM
00001122  4E72 0100                306      STOP        #$0100 *JMP         sub_LEA
00001126                           307      
00001126  4E72 DEAD                308      STOP        #$DEAD *JMP         sub_CHK * not required
0000112A                           309      
0000112A                           310  ; 0110
0000112A                           311  jmpTable0110
0000112A  4E72 0110                312      STOP        #$0110 *JMP         sub_BRA
0000112E                           313      
0000112E  4EF8 108C                314      JMP         invalidOpcode       * BSR not required
00001132  4EF8 108C                315      JMP         invalidOpcode       * BHI not required
00001136  4EF8 108C                316      JMP         invalidOpcode       * BLS not required
0000113A  4EF8 108C                317      JMP         invalidOpcode       * BCC not required
0000113E  4EF8 108C                318      JMP         invalidOpcode       * BCS not required
00001142  4EF8 108C                319      JMP         invalidOpcode       * BNE not required
00001146                           320      
00001146  4E72 0110                321      STOP        #$0110 *JMP         sub_BEQ
0000114A                           322      
0000114A  4EF8 108C                323      JMP         invalidOpcode       * BVC not required
0000114E  4EF8 108C                324      JMP         invalidOpcode       * BVS not required
00001152  4EF8 108C                325      JMP         invalidOpcode       * BPL not required
00001156  4EF8 108C                326      JMP         invalidOpcode       * BMI not required
0000115A  4EF8 108C                327      JMP         invalidOpcode       * BGE not required
0000115E  4EF8 108C                328      JMP         invalidOpcode       * BLT not required
00001162                           329      
00001162  4E72 0110                330      STOP        #$0110 *JMP         sub_BGT
00001166  4E72 0110                331      STOP        #$0110 *JMP         sub_BLE
0000116A                           332      
0000116A                           333      
0000116A                           334  ; 1000
0000116A                           335  jmpTable1000
0000116A  4E72 1000                336      STOP        #$1000 *JMP         sub_DIVU
0000116E                           337      
0000116E  4E72 DEAD                338      STOP        #$DEAD *JMP         sub_DIVS * not required
00001172  4E72 DEAD                339      STOP        #$DEAD *JMP         sub_SBCD * not required
00001176  4E72 DEAD                340      STOP        #$DEAD *JMP         sub_OR * not required
0000117A                           341      
0000117A                           342  ; 1100
0000117A                           343  jmpTable1100
0000117A  4E72 DEAD                344      STOP        #$DEAD *JMP         sub_MULU * not required
0000117E                           345      
0000117E  4E72 1100                346      STOP        #$1100 *JMP         sub_MULS
00001182                           347      
00001182  4E72 DEAD                348      STOP        #$DEAD *JMP         sub_ABCD * not required
00001186  4E72 DEAD                349      STOP        #$DEAD *JMP         sub_EXG * not required
0000118A                           350      
0000118A  4E72 1100                351      STOP        #$1100 *JMP         sub_AND
0000118E                           352      
0000118E                           353  ; 1101
0000118E                           354  jmpTable1101
0000118E  4E72 1101                355      STOP        #$1101 *JMP         sub_ADD
00001192  4E72 DEAD                356      STOP        #$DEAD *JMP         sub_ADDX * not required
00001196  4E72 DEAD                357      STOP        #$DEAD *JMP         sub_ADDA * not required
0000119A                           358      
0000119A                           359  ; 1110
0000119A                           360  jmpTable1110
0000119A  4E72 1110                361      STOP        #$1110 *JMP         sub_ASd ; for ASR/ASL
0000119E  4E72 1110                362      STOP        #$1110 *JMP         sub_LSd ; for LSR/LSL
000011A2  4E72 DEAD                363      STOP        #$DEAD *JMP         sub_ROXd * not required
000011A6  4E72 1110                364      STOP        #$1110 *JMP         sub_
000011AA                           365      
000011AA                           366  
000011AA                           367  sub0100_000
000011AA                           368  ; required: LEA
000011AA                           369  ; invalid: MOVE from SR, NEGX, (possibly) CHK
000011AA                           370  
000011AA                           371  sub0100_001
000011AA                           372  ; required: 
000011AA                           373  ; invalid: 
000011AA                           374  
000011AA                           375  sub0100_010
000011AA                           376  ; required: 
000011AA                           377  ; invalid: 
000011AA                           378  
000011AA                           379  sub0100_100
000011AA                           380  ; required: 
000011AA                           381  ; invalid: 
000011AA                           382  
000011AA                           383  sub0100_101
000011AA                           384  ; required: 
000011AA                           385  ; invalid: 
000011AA                           386  
000011AA                           387  sub0100_110
000011AA                           388  ; required: 
000011AA                           389  ; invalid: 
000011AA                           390  
000011AA                           391  sub0100_111
000011AA                           392  ; required: RTS,JSR,LEA (if dest is A7)
000011AA                           393  ; invalid: 
000011AA                           394  
000011AA                           395  -------------------- end include --------------------
000011AA                           396  *    ORG         $1800
000011AA                           397  ; jump table for bits 15-12 of an instruction opcode
000011AA                           398  firstJmpTable
000011AA  4EF8 108C                399      JMP         invalidOpcode       ; 0000 are all invalid
000011AE  4EF9 00001200            400      JMP         moveByte
000011B4  4EF9 00001204            401      JMP         moveLong
000011BA  4EF9 00001208            402      JMP         moveWord
000011C0  4EF9 0000120C            403      JMP         code0100            ; NOT,NOP,RTS,JSR,MOVEM,LEA
000011C6  4EF8 108C                404      JMP         invalidOpcode       ; 0101 are all invalid
000011CA  4EF9 00001240            405      JMP         branchJmpTable      ; BRA,BEQ,BGT,BLE. rest are invalid
000011D0  4EF8 108C                406      JMP         invalidOpcode       ; MOVEQ is invalid
000011D4  4EF9 0000125C            407      JMP         code1000            ; DIVU, rest are invalid
000011DA  4EF9 00001276            408      JMP         subOpcodeIdentify   ; SUB, rest are invalid
000011E0  4EF8 108C                409      JMP         invalidOpcode       ; no opcodes have 1010    
000011E4  4EF8 108C                410      JMP         invalidOpcode       ; 1011 are all invalid
000011E8  4EF9 00001292            411      JMP         code1100            ; MULS,AND good. rest are invalid
000011EE                           412                                      ; TODO: distinguish MULS or AND in code1100
000011EE  4EF9 00001296            413      JMP         addJmpTable
000011F4  4EF9 0000129A            414      JMP         shiftJmpTable
000011FA  4EF9 0000129E            415      JMP         code1111            ; idk if any required opcodes have these bits
00001200                           416                                      ; TODO: check this
00001200                           417      
00001200                           418      
00001200                           419  ; these methods set A0 to their specific jump table in secondJmpTable.X68
00001200                           420  ; exceptions to this pattern are moveByte, moveLong, moveWord, and moveQ
00001200                           421  moveByte     
00001200                           422      ; Move Byte
00001200                           423      
00001200  4E72 2700                424      STOP        #$2700
00001204                           425  
00001204                           426  moveLong  
00001204                           427      ; Move Long     
00001204  4E72 2700                428      STOP        #$2700
00001208                           429  
00001208                           430  moveWord  
00001208                           431      ; Move Word     
00001208  4E72 2700                432      STOP        #$2700
0000120C                           433  
0000120C                           434  code0100  
0000120C                           435      ; NOT: bits 11-8 always 0110 and bits 7-6 never 11
0000120C                           436      ; only other opcode in this section with 11-8 0110 is MOVE to SR (7-6 always 11)
0000120C                           437      ; NOP: always 4E71    
0000120C                           438      ; RTS: always 4E74
0000120C                           439      ; JSR: bits 11-6 always 111010
0000120C                           440      ; MOVEM: 
0000120C                           441      ; LEA: bits 8-6 always 111
0000120C                           442      
0000120C                           443      ; LEA and CHK are wildcards because their 11-8's are variables
0000120C                           444      ; let's check for them specifically before the other instructions
0000120C                           445      ; I should also check for MOVEM if possible due to variable bit 10
0000120C                           446m     isolateBitsM    D4,#8,#6
0000120C                           447m     ; ARGS SAME AS ABOVE, EXCEPT THEY're immediates or different regs
0000120C                 FALSE     448m     IFNE 3-3                       ;IF NOT 3 ARGUMENTS
0000120C                           449m     ENDC
0000120C  2004                     450m     MOVE.L      D4,D0
0000120E  123C 0008                451m     MOVE.B      #8,D1
00001212  143C 0006                452m     MOVE.B      #6,D2
00001216  6100 FDE8                453m     BSR         ISOLATEBITS
0000121A                           454m     ENDM
0000121A  B03C 0006                455      CMP.B           #6,D0
0000121E  6700 FE6C                456      BEQ             invalidOpcode       ; CHK 8-6 is 110 or 6
00001222                           457      ;BGT             sub_lea             ; LEA is only 0100 opcode with 8-6 > 110 (111)
00001222                           458      
00001222                           459  
00001222                           460      ; now check for MOVEM
00001222                           461m     isolateBitsM    D4,#11,#7
00001222                           462m     ; ARGS SAME AS ABOVE, EXCEPT THEY're immediates or different regs
00001222                 FALSE     463m     IFNE 3-3                       ;IF NOT 3 ARGUMENTS
00001222                           464m     ENDC
00001222  2004                     465m     MOVE.L      D4,D0
00001224  123C 000B                466m     MOVE.B      #11,D1
00001228  143C 0007                467m     MOVE.B      #7,D2
0000122C  6100 FDD2                468m     BSR         ISOLATEBITS
00001230                           469m     ENDM
00001230                           470      ; null bit 10 since it's not constant for MOVEM
00001230  0200 0017                471      ANDI.B      #23,D0
00001234  B03C 0011                472      CMP.B       #17,D0
00001238                           473      ;BEQ         sub_movem
00001238  41F8 10B2                474      LEA         jmpTable0100, A0
0000123C  4E72 2700                475      STOP        #$2700
00001240                           476  
00001240                           477  branchJmpTable 
00001240  4AFC                     478      ILLEGAL     ; as a test breakpoint
00001242  3004                     479      MOVE.W      D4, D0
00001244  123C 000B                480      MOVE.B      #11, D1
00001248  143C 0008                481      MOVE.B      #8, D2
0000124C  6100 FDB2                482      BSR         isolateBits
00001250  41F8 112A                483      LEA         jmpTable0110, A0  
00001254                           484      
00001254                           485      ; BSR so we can return here to calc displacement
00001254  6100 FDBA                486      BSR         calcJmpOffset
00001258                           487      
00001258                           488      ; TODO: displacement shit. Might need to generate a label (which would be aids)
00001258                           489      ; complete this code later
00001258  4E72 2700                490      STOP        #$2700
0000125C                           491  
0000125C                           492  code1000   
0000125C                           493      ; DIVU is the only opcode we care about here 
0000125C                           494      ; DIVU: bits 8-6 are always 011
0000125C                           495m     isolateBitsM    D4,#8,#6
0000125C                           496m     ; ARGS SAME AS ABOVE, EXCEPT THEY're immediates or different regs
0000125C                 FALSE     497m     IFNE 3-3                       ;IF NOT 3 ARGUMENTS
0000125C                           498m     ENDC
0000125C  2004                     499m     MOVE.L      D4,D0
0000125E  123C 0008                500m     MOVE.B      #8,D1
00001262  143C 0006                501m     MOVE.B      #6,D2
00001266  6100 FD98                502m     BSR         ISOLATEBITS
0000126A                           503m     ENDM
0000126A  B07C 0003                504      CMP.W           #3,D0
0000126E  6600 FE1C                505      BNE             invalidOpcode
00001272                           506      ; we know the input is DIVU, so do something now....
00001272                           507    
00001272  4E72 2700                508      STOP        #$2700
00001276                           509  
00001276                           510  subOpcodeIdentify 
00001276                           511      ; if bits 7-6 are 11, opcode is SUBA
00001276                           512      ; table for SUB
00001276                           513      ; since SUB is the only valid opcode here, just compare.
00001276                           514      ; if dest is a data reg, the opcode is sub
00001276                           515      ; otherwise, invalid opcode
00001276                           516      ; SUBI has different 15-12 bits so we don't worry about it
00001276                           517  
00001276                           518      ; AND with a bitmask of 0x1F0 to check for both SUBA and SUBX
00001276  3004                     519      MOVE.W  D4,D0
00001278  0240 01F0                520      ANDI.W  #$1F0,D0
0000127C                           521      
0000127C                           522      ; if result is 0xC0, it's SUBA
0000127C                           523      ; if result is 0x140, it's SUBX
0000127C                           524      ; anything else is SUB
0000127C  B07C 00C0                525      CMP.W   #$C0,D0
00001280  6700 FE0A                526      BEQ     invalidOpcode
00001284  B07C 0140                527      CMP.W   #$140,D0
00001288  6700 FE02                528      BEQ     invalidOpcode
0000128C                           529  
0000128C                           530  * The following should work but is inefficient    
0000128C                           531  *    ; SUBA check
0000128C                           532  *    isolateBitsM    D4,#7,#6
0000128C                           533  *    CMP.B           #3,D0
0000128C                           534  *    BEQ             invalidOpcode
0000128C                           535  *    
0000128C                           536  *    ; TODO: distinguish between SUB & SUBX  
0000128C                           537  *    ; trying out a bitmask of 304 - 0x130 (1 0011 0000), checking if result == 256 - 0x100
0000128C                           538  *    MOVE.W          D4,D0
0000128C                           539  *    ANDI.W          #304,D0
0000128C                           540  *    CMP.W           #256,D0
0000128C                           541  *    BEQ             invalidOpcode   
0000128C                           542   
0000128C                           543      ; do stuff
0000128C                           544     
0000128C  4E72 2700                545      STOP        #$2700
00001290                           546  
00001290                           547  code1011
00001290                           548      ; 
00001290  60FE                     549      BRA        code1011
00001292                           550  
00001292                           551  code1100
00001292                           552      ; ABCD: bits 8-4 are always 10000
00001292                           553      ; MULS: bit 8 is always 1 vs MULU where it's always 0
00001292                           554      ; ANDI has different 15-12 bits than AND
00001292  4E72 2700                555      STOP        #$2700
00001296                           556  
00001296                           557  addJmpTable  
00001296                           558      ;     
00001296  4E72 2700                559      STOP        #$2700
0000129A                           560  
0000129A                           561  shiftJmpTable  
0000129A                           562      ; table for 
0000129A  4E72 2700                563      STOP        #$2700
0000129E                           564  
0000129E                           565  code1111    
0000129E                           566      ; Special/Reserved   
0000129E  4E72 2700                567      STOP        #$2700
000012A2                           568      
000012A2                           569  
000012A2                           570  *   END         firstJmpTable
000012A2                           571  
000012A2                           572  
000012A2                           573  
Line 574 WARNING: END directive missing, starting address not set

No errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDJMPTABLE         1296
BRANCHJMPTABLE      1240
CALCDISPLACEMENTADDRESS  101A
CALCJMPOFFSET       1010
CODE                0
CODE0100            120C
CODE1000            125C
CODE1011            1290
CODE1100            1292
CODE1111            129E
FIRSTJMPTABLE       11AA
GETEXTENSION        1046
GETEXTENSIONRETURN  1062
GETFIRSTEXT         1036
GETOPCODE           1026
GETSECONDEXT        1040
INSTR_BYTES         1082
INSTR_EXT_1         1084
INSTR_EXT_2         1088
INSTR_OPCODE_WORD   1082
INVALIDOPCODE       108C
ISOLATEBITS         1000
ISOLATEBITSM        321
JMPTABLE0100        10B2
JMPTABLE0110        112A
JMPTABLE1000        116A
JMPTABLE1100        117A
JMPTABLE1101        118E
JMPTABLE1110        119A
MOVEBYTE            1200
MOVELONG            1204
MOVEWORD            1208
MSG_2               2000
MSG_3               2018
PRINT               0
PRINTN              13E
SETFIRSTEXT         1072
SETOPCODE           1064
SETSECONDEXT        107A
SHIFTJMPTABLE       129A
SUB0100_000         11AA
SUB0100_001         11AA
SUB0100_010         11AA
SUB0100_100         11AA
SUB0100_101         11AA
SUB0100_110         11AA
SUB0100_111         11AA
SUBOPCODEIDENTIFY   1276
TEXT                1
